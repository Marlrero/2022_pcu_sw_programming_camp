# 퀵 정렬
## 문제
정렬(sorting)은 데이터를 크기 순으로 오름차순(ascending order)이나 내림차순(descending order)으로 나열하는 것을 말한다.
정렬은 컴퓨터공학의 알고리즘 분야에서 가장 기본적인 알고리즘으로 일상생활에서도 많이 쓰인다.
예를 들어 상품을 가격 순으로 보여줄 때, 파일 크기 순으로 정렬할 때 사용된다.  
정렬 알고리즘은 매우 많으며, 모든 경우에 있어 최상의 성능을 보여주는 최적의 알고리즘은 존재하지 않는다. 상황이나 수행 환경에 따라 정렬 알고리즘을 적절히 선택해서 사용해야 한다.  
정렬 알고리즘의 성능은 두 데이터를 비교하기 위한 연산의 횟수와 이동해야 하는 횟수로 결정되며 이러한 횟수를 정확하게 구하기는 힘들기 때문에 빅오 표기법(big-O notation)으로 표현된다.  
컴퓨터공학의 알고리즘에서 배우는 정렬 알고리즘은 다음과 같다.
- 단순하지만 비효율적인 방법: 삽입 정렬, 선택 정렬, 버블 정렬 등 -> 대게 빅오 표기법으로 O(n^2)이다.
- 복잡하지만 효율적인 방법: 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬 등 -> 대게 빅오 표기법으로 O(n log n)이다.

이 중에서 퀵 정렬은 평균적으로 가장 빠른 수행 속도를 보이는 정렬 알고리즘이다. 알고리즘 분야에서 분할 정복(divide and conquer) 방법에 근거해,
전체 데이터를 2개의 부분 데이터로 분할하고, 각각의 부분 데이터를 다시 퀵 정렬을 수행한다. (재귀적임)  
먼저 데이터의 모음을 리스트라고 가정하면, 이 리스트를 비균등하게 분할하고, 리스트 안에 있는 한 요소를 피벗(pivot)으로 선택한다. 피벗을 선택하는 방식은 다양하게 있으며, 여기서는 첫 번째 요소를 선택한다고 가정하자.  
피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고, 피벗보다 큰 요소들은 피벗의 오른쪽으로 옮겨야 한다.
이 상태에서 피벗을 제외한 나머지 왼쪽 리스트와 오른쪽 리스트를 다시 정렬하게 된다.  
- 퀵 정렬 알고리즘의 구성은 아래와 같이 함수 2개로 구성된다.
    ```
    1) void quick sort(int list[], int left, int right);
    2) int partiton(int list[], int left, int right);
    ```
- partition 함수는 데이터가 들어있는 배열 list의 left부터 right까지의 리스트를 피벗을 기준으로 2개의 부분 리스트로 나누며 피벗보다 작은 데이터는 모두 왼쪽으로, 피벗보다 큰 데이터는 오른쪽으로 옮기는 함수이다.

위와 같이 설명한 대로, 퀵 정렬을 구현하시오.

## 입력 예 및 출력 예
숫자 입력(x를 입력하면 정렬하기): 5  
3  
8  
4  
9  
1  
6  
2  
7  
x  
1, 2, 3, 4, 5, 6, 7, 8, 9