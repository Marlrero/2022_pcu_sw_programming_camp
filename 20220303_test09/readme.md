# 깊이 우선 탐색과 너비 우선 탐색
## 문제1
깊이 우선 탐색(Depth First Search: DFS)는 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지
계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터
다른 방향으로 다시 탐색을 진행하는 방법에서 사용된다.  
깊이 우선 탐색은 그래프의 시작 노드부터 출발해 먼저 시작 노드 v를 방문하고 
방문하였다고 표시한다. v에 인접한 정점들 중에서 아직 방문하지 않은 노드 u를 선택한다.
만약 이러한 노드가 없다면 탐색은 종료된다. 탐색이 끝나게 되면 다시 노드 v에 인접한 노드들
중에서 아직 방문이 안 된 정점을 찾는다. 만약 없다면 종료하고, 있다면 다시 그 노드를
시작 노드로 하여 깊이 우선 탐색을 다시 시작한다.  
깊이 우선 탐색은 재귀적으로 풀 수도 있고, 스택을 사용해서도 해결할 수 있다.
사실, 재귀 함수 호출은 메모리의 스택 영역에 함수의 호출 정보가 들어가므로, 같은 구현이라고도
볼 수 있다.   
깊이 우선 탐색의 의사 코드는 아래와 같다.
```
depth_first_search(v)
	v를 방문했다고 표시함;
	for all u in (v에 인접한 노드) do
		if (u가 아직 방문하지 않았으면)
			then depth_first_search(u)
```
깊이 우선 탐색은 인접 배열로도 풀 수 있고, 인접 리스트로도 해결 가능하다.
두 가지 방법 중 하나를 선택하여 해결하라.

## 문제2
너비 우선 탐색(Breadth First Search: BFS)은 시작 노드로부터 가까운 정점을 먼저 방문하고
멀리 떨어져 있는 노드를 나중에 방문하는 순회 방법이다.  
너비 우선 탐색을 위해서 방문한 정점들을 차례로 저장한 후 꺼낼 수 있는 자료구조인 큐(queue)가
필요하다. 즉 노드를 방문할 때마다 큐에 방문된 노드를 삽입하고, 더 이상 방문할 인접 노드가
없다면 큐의 앞에서 노드를 꺼내어 그 노드와 인접한 노드들을 모두 차례대로 방문하게 된다.  
너비 우선 탐색의 의사 코드는 아래와 같다.
```
breadth_first_search(v)
	v를 방문했다고 표시;
	큐에 노드 v를 삽입;
	while (not is_empty(Q)) do
		큐에서 노드 w를 삭제;
		for all u in (w에 인접한 노드) do
			if (u가 아직 방문되지 않았으면)
				then u를 큐에 삽입;
				      u를 방문했다고 표시;
```
깊이 우선 탐색도 인접 배열로도 풀 수 있고, 인접 리스트로도 해결 가능하다.
두 가지 방법 중 하나를 선택하여 해결하라.
또한 저번에 구현한 큐(배열, 리스트 형태 둘 중 선택)를 활용하라.